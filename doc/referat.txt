БОТ ДЛЯ РУССКИХ ШАШЕК

Оглавление:
	1. Предисловие
		1.1 цели и мотивация
		1.2 структура доклада
	2. Введение
		2.1 правила русских шашек
		2.2 описание использованных инструментов
	3. Разбор реализации шашек
		3.1 bitboard
		3.2 bitscan
		3.3 генерация ходов
			3.3.1 проверка возможности взятия
			3.3.2 простой ход шашкой
			3.3.3 простой ход дамкой
			3.3.4 взятие шашкой
			3.3.5 взятие дамкой
		3.4 обнаружение троекратного повторения
	4 Разбор реализации шашечного компьютера
		4.1 алгоритм минимакс
		4.2 евалюционная оценка позиции
		4.3 альфа-бета отсечение
		4.4 эффект горизонта
	5. Разбор реализации графического интерфейса
		5.1 общее описание
		5.2 библиотека sfml
		5.3 подробное описание устройства UI
		5.4 недоработки интерфейса и пространство для улучшения
	6. Анализ поведения


1. Предисловие:
	1.1 Цели и мотивация:
			В последние несколько десятилетий технологии развиваются невероятно быстро, и начинают помогать человеку практически во всем, и спорт здесь не
		исключение. В 1997 году компьютер deep-blue выиграл шахматный матч у действующего чемпиона мира по шахматам Гари Каспарова со счетом 3,5:2,5.
		С того момента шахматные программы стали доступны всем. Благодаря им у шахматистов во всем мире появилась возможность анализировать партии
		Во многом из-за этого в последне время сильно вырос средний уровень игры в шахматы. Думаю очевидно, что такие программы для шашек и шахмат
		помогут как начинающим, так и сильным игрокам.
	1.2 Структура доклада:
			Раздел 2 это введение, в котором описаны правила русских шашек и использованный метод анализа алгоритмов. Его понимание необходимо для 
		ознакомления с проектом. В 3, 4 и 5 разделax описано устройство реализации шашек, бота и интерфейса соответственно. В 6 описанно 
		исследование поведения программы при различных сценариях.
2. Введение:
	2.1 правила русских шашек:
			Среди всех разновидностей шашек были выбраны русские, т.к они (в отличие от международных) играются на доске 8*8, что совпадает с размером типа
		uint64_t(в с++) битах. Это совпадение серьезно упрощает хранение доски(подробнее в разделе 3.1).

		Основные правила:
			- Изначально 12 белых и 12 черных шашек расположенны только на черных клетках как показано ниже
				0_0_0_0_
				_0_0_0_0
				0_0_0_0_
				________
				________
				_0_0_0_0
				0_0_0_0_
				_0_0_0_0
			- Простая шашка ходит по диагонали вперёд на одну клетку.
			- Дамка ходит по диагонали на любое свободное поле как вперёд, так и назад, но не может перескакивать свои шашки или дамки
			- Взятие обязательно. Побитые шашки и дамки снимаются только после завершения хода (В моей программе снимаются срау, т.к. это серьезно
			упрощает реализацию, а из-за правила турецкого удара результат не меняется)
			- При взятии простая шашка, находящаяся рядом с шашкой соперника, за которой имеется свободное поле, 
			переносится через эту шашку на это свободное поле
			- Если есть возможность продолжить взятие других шашек соперника, то это взятие продолжается
			- Дамка бьёт по диагонали, как вперёд, так и назад, и становится на любое свободное поле после побитой шашки. Аналогично, дамка 
			может бить несколько фигур соперника и должна бить до тех пор, пока это возможно.
			- При взятии применяется правило турецкого удара — за один ход шашку противника можно побить только один раз. То есть, если при бое 
			нескольких шашек противника шашка или дамка повторно выходит на уже побитую шашку, то ход останавливается.
			- При нескольких вариантах взятия, например, одну шашку или две, игрок выбирает вариант взятия по своему усмотрению.

		 Считаю важным заострить внимание на следующих тонкостях в правилах игры:
			- если одна позиция повторяется 3 раза засчитывается ничья
			- если 15 ходов подряд ходят только дамки, не производя взятия, засчитывается ничья
			- если участник, имеющий три дамки (и более) против одной дамки противника, за 15 ходов не возьмёт дамку противника засчитывается ничья
			- засчитывается ничья, если в позиции, в которой оба соперника имеют дамки, не было взятия, и ни одна простая шашка не стала дамкой за
				в 2-3 -фигурных окончаниях — 5 ходов,
				в 4-5 -фигурных окончаниях — 30 ходов,
				в 6-7 -фигурных окончаниях — 60 ходов
			- При бое через дамочное поле простая шашка превращается в дамку и продолжает бой по правилам дамки
	3. Разбор реализации шашек
		3.1 bitboard
			Существует довольно удобная система представления доски, называемая битовыми досками. Идея строится на замечательном совпадении: доска содержит
		64 клетки, когда как современные компьютеры умеют невероятно быстро работать с 64 битовыми числами(Не делалось поправки на то, что шашки не 
		могут стоять на белых клетках, т.к. реализация системы не хранящей состояния белых клеток была бы в разы сложнее, а за незначительный выигрыш
		памяти(озу занимаемая всем проектом уменьшилась бы чуть меньше чем в 2 раза) пришлось бы заплатить производительностью). Для хранения всей позиции
		достаточно 4 чисел - c белыми шашки, с черными шашками, c белыми дамки, c черными дамками. В моем прокте дополнительно хранятся битборды для 
		шашек всех цветов, дамок всех цветов и всех фигур. Для удобства написания кода закрепим назквания Bitboard и Square за типами uint64_t и uint8_t
		соответственно
			types.h:
				typedef uint64_t Bitboard;
				typedef uint8_t Square;
		Снизу написаны использованные в моем проекте функции сдвига доски на один шаг в разных направлениях.
			bitboard.h:
				constexpr Bitboard W_move(Bitboard bb) {
					// устанавливаем значение 0 во все крайние правые биты и сдвигаем на один бит вправо
					return (bb & 0xfefe'fefe'fefe'fefe) >> 1;
				}
				constexpr Bitboard E_move(Bitboard bb) {
					return (bb & 0x7f7f'7f7f'7f7f'7f7f) << 1;
				}
				constexpr Bitboard NW_move(Bitboard bb) {
					return W_move(bb) << 8;
				}
				constexpr Bitboard NE_move(Bitboard bb) {
					return E_move(bb) << 8;
				}
				constexpr Bitboard SW_move(Bitboard bb) {
					return W_move(bb) >> 8;
				}
				constexpr Bitboard SE_move(Bitboard bb) {
					return E_move(bb) >> 8;
				}
		В данном случае W - west, E - east, NW - north-west, и т.д.
		Я также реализовал приведенные ниже функциии обращения по индексам и подсчета еденичных битов
			bitboard.h:
				constexpr void set_1(Bitboard& bb, Square s) {
					bb |= 1ull << s;
				}
				constexpr void set_0(Bitboard& bb, Square s) {
					bb &= ~(1ull << s);
				}
				constexpr bool getbit(Bitboard bb, Square s) {
					return bb & (1ull << s);	
				}
				inline uint8_t bb_popcount(Bitboard bb) {
					  return __builtin_popcountll(bb); // работает только в g++
				}
		Помимо этого я написал описанные в следующем подразделе функции bsf(ищет первый единичный бит в битборде) и bsf(ищет последний еденичный бит),
		а также с их использованием итератор который выдает по очереди номера всех квадратов с еденичными битами. Всю подобные элементарные функции
		обработки битбордов можно найти в файлах src/bitboard.h и src/bitboard.cpp.
		3.2 bitscan
		Заметим, что если 
		3.3 лучи
		В дальнейшем, для генерации ходов нам понадобится возможность быстро находить первую фигуру стоящую на луче. Для этого создадим матрицу 4*64, 
		вычисляемую на этапе комптляции, которая будет состоять из 4 массивов(по одному для каждого направления), содержащих по 64 битборда(по одному
		на каждую клетку) , в каждом из которых еденичные биты образуют луч
			types.h:
				typedef std::array<Bitboard, 64> Map;
			attacks.h:
				constexpr std::array<Map, 4> init_xrays() {
					std::array<Map, 4> res;
					for (Square s = 0; s < 64; s++) {
						std::array<Bitboard, 4> bb;
						for (int i = 0; i < 4; i++)
							bb[i] = 1ull << s;
						for (int i = 0; i < 8; i++) {
							bb[0] |= NE_move(bb[0]);
							bb[1] |= NW_move(bb[1]);
							bb[2] |= SE_move(bb[2]);
							bb[3] |= SW_move(bb[3]);
						}
						for (int i = 0; i < 4; i++) {
							set_0(bb[i], s);
							res[i][s] = bb[i];
						}
					}
					for (int i = 0; i < 4; i++)
						res[i][NONE_SQUARE] = 0;

					return res;
				}
				constexpr std::array<Map, 4> xrays = init_xrays();
			Теперь для нахождения первого единичного бита в битборде попавшего на луч пользуемся тем что он будет крайнем на битборде полученном
			пересечением проверяемой доски и нужного элемента матрицы xrays

		3.4 генерация ходов
			3.3.1 генерация простых ход шашкой
			Для генерации ходов шашки вычислим возможные ходы из каждого поля на этапе компиляции
			attacks.h:
				constexpr std::array<Map, 2> init_disc_moves() {
					std::array<Map, 2> r;
					for (Square s = 0; s < 64; s++) {
						r[WHITE][s] = NE_move(1ull << s) | NW_move(1ull << s);
						r[BLACK][s] = SE_move(1ull << s) | SW_move(1ull << s);
					}
					return r;
				}
				constexpr std::array<Map, 2> disc_moves = init_disc_moves();
			и в нужный момент просто будем выдовать заранее вычесленные ходы, с поправкой на непустые поля
			position.h:
				disc_moves[p][s] & ~все_фигуры;

			3.3.2 генерация ходов остальных фигур, проверка возможности взятия и блокировки
				Полувзятием буду называть маневр взятия только одной шашки, которыое возможно можно и нужно продолжить.
			Очень просто при помощи побитовых операций можно сгенерировать возможные взятия шашкой
			position.cpp:
				NE_move(все_фигуры_противника & NE_move(1ull << s)) & ~все_фигуры |
				NW_move(все_фигуры_противника & NW_move(1ull << s)) & ~все_фигуры |
				SE_move(все_фигуры_противника & SE_move(1ull << s)) & ~все_фигуры |
				SW_move(все_фигуры_противника & SW_move(1ull << s)) & ~все_фигуры;
			Вот так можно проверить возможность взятия простыми шашками
			position.cpp:
				if (
					NE_move(все_фигуры_противника & NE_move(шашки_проверяемого_игрока)) & ~все_фигуры or
					NW_move(все_фигуры_противника & NW_move(шашки_проверяемого_игрока)) & ~все_фигуры or
					SE_move(все_фигуры_противника & SE_move(шашки_проверяемого_игрока)) & ~все_фигуры or
					SW_move(все_фигуры_противника & SW_move(шашки_проверяемого_игрока)) & ~все_фигуры or
				) ...
			А так проверка существования возможных ходов(не взятий)
				inline bool Position::is_blocked(Side p) const {
					bool r = false;
					if (проверяем белых)
						r |=
							not (NE_move(все_шашки_игрока) & ~все_фигуры) and
							not (NW_move(все_шашки_игрока) & ~все_фигуры);
					else
						r |=
							not (SE_move(все_шашки_игрока) & ~все_фигуры) and
							not (SW_move(все_шашки_игрока) & ~все_фигуры);

					r &= not (
						(
							NE_move(все_дамки_игрока) |
							NW_move(все_дамки_игрока) |
							SE_move(все_дамки_игрока) |
							SW_move(все_дамки_игрока)
						) & ~все_фигуры
					);
					return r;
				}
				Генерация ходов и полувзятий дамки реализованна на основе описанных ранее операций с лучами, для проверки возможности взятия
				дамкой по отдельности генерируются полувзятия для каждой из дамок
		3.5 обнаружение троекратного повторения
			Для проверки на троекратное повторение после каждого хода будем проверять сколько раз эта позиция встречалась до этого, но для оптимизации
			воспользуемся тем, что любой ход кроме простого(не взятия) хода дамкой не обратим. Т.е. каждый раз можно проверять сколько раз встречалась эта
			позиция до последнего необратимого хода, а не во всей игре. Т.к. любой ход шашкой необратим можно каждый раз сравнивать только позиции дамок.
	4 Разбор реализации шашечного компьютера
		4.1 алгоритм минимакс
		Напишем простую функцию оценки позиции, которая будет выдавать разность числа белых и черных шашек. Очевидно, что белые в своей игре будут 
		стараться максимизировать эту оценку, а черные наоборот максимизировать(В данном случае игрока, играющего белыми, называют игроком максиимализации,
		а черные игроком минимализации). Однако програма просто выбирающая позицию с лучшей статической оценкой не видит возможных вариантов развития игры 
		Позиция с хорошей статической оценкой может быть проигрышной. Программа пытающаяся извлечь сеиминутную материальную прибыль никогда не выбет ход 
		приводящий к выигрышу через жертву. Поэтому введем динамическую оценку позиции, которая будет выдавать динамическую оценку(с глубиной на еденицу 
		меньшей) лучшей, для активного игрока, из всех следующих позиций. Динамическая оценка с нулевой глубиной - это статическая оценка. Таким образом 
		динамическая оценка с глубиной n показывает статическую оценку которую игрок может достичь через n ходов независимо от игры противника. Этот 
		алгоритм динамической оценки называется минимакс.
		4.2 альфа-бета отсечение
		Альфа-бета-отсечение — алгоритм поиска, стремящийся сократить количество узлов, оцениваемых в дереве поиска алгоритмом минимакса. В основе 
		алгоритма лежит идея, что оценивание ветви дерева поиска может быть досрочно прекращено (без вычисления всех значений оценивающей функции), 
		если было найдено, что для этой ветви значение оценивающей функции в любом случае хуже, чем вычисленное для предыдущей ветви. Альфа-бета-отсечение
		является оптимизацией, так как не влияет на корректность работы алгоритма. Для обнаружения возможности досрочного прекращения анализа введем
		два значения альфа и бета, котороые будут содержать нижнюю и верхние границы ожидаемых значений для игрока максимизации а минимализации
		соответственно. Если в какой-то момент альфа больше чем бета, то ожидания игроков удвлетворить невозможно, и дальнейший анализ этой ветви
		бессмысленен. Ниже приведена иллюстрация применения этой оптимизации для предыдущего примера. Обратите внимание, что ожидания игроков сохраняются
		при переходе на следующу глубину анализа.
		4.3 эффект горизонта
		Заметим, что если работающая по описаному выше принципу программа с найдет способ выиграть шашку путем жертвы своей она попытается это сделать.
		Но если после выигрыша шашки анализ был прекращен(была достигнута максимальная глубина) есть вероятность, что она сразу=же отыгрывается.
		Этот эффект, названный эффектом горизонта, заставляет компьютер переодически делать нелепые ходы. Чтобы решить эту проблему не будем прерывать
		анализ при достижение максимальной глубины анализа после взятия, а продолжим на еще один ход.
	5 Немного о графическом интерфейсе
		Графический интерфейс сделан довольно просто, как примитивный способ взаимодействия с моей программой. В классе Drawer(описаном в заголовочном
		файле drawer.h) реализована отрисовка доски, а также описаны методы выделения определенных полей цветом и получения поля выбранного
		пользователем. Все эти методы использованны в классе Interface(описанном в interface.h), инкапсулирующем всю остальную логику взаимодействия 
		игрока с программой. Для отрисовки интерфейса была выбранна библиотек SFML, т.к. она предоставляет простые методы рисования графических 
		примитивов, использованные в программе. Я считаю, что интерфейс следовало бы реализовать как независимую от движка программу, что очень легко 
		сделать благодаря выбранной объектной архитектуре, если просто заменив класс Interface, с текущего на реализущий взаимодействие с таким программой.
	6 Анализ поведения
